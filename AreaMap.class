import java.util.*;

public class AreaMap {
	private ArrayList<Node> nodes = new ArrayList<>();
	private Map<Node, ConnectedNodes[]> map = new HashMap<Node, ConnectedNodes[]>();
	private int mapSize, numberOfConnections, randTemp, pathCost=0, shortestPathCost = 0, k =0;
	private int[] placeMarkers;
	private ArrayList<ConnectedNodes[]> CN = new ArrayList<>();
	private ArrayList<Integer> prevs = new ArrayList<>();
	//private ArrayList<ArrayList<ConnectedNodes>> possiblePaths= new ArrayList<>();
	private ArrayList<Node> shortestPath = new ArrayList<>();
	private ArrayList<Node> path = new ArrayList<>();
	private String printIt = "";
	private Node currNode, prevNode;
	
	public AreaMap(int mapSize, int numberOfConnections){
		this.mapSize = mapSize;
		this.numberOfConnections = numberOfConnections;
		this.placeMarkers = new int[mapSize-1];
		for(int i = 0; i< mapSize; i++){
			nodes.add(new Node((char)(65+i)));
			CN.add(new ConnectedNodes[numberOfConnections]);
		}
		
		for (int i = 0; i < mapSize - 1; i++){
			placeMarkers[i] = 0;
		}
		
		for (int i = 0; i < mapSize; i++){
			for (int j = 0; j < numberOfConnections; j++){
				randTemp = (int) (Math.random()*mapSize);
				
				while ((randTemp == i)||(prevs.contains(randTemp))){
					randTemp = (int) (Math.random()*mapSize);
				}
				prevs.add(randTemp);
				
				CN.get(i)[j] = new ConnectedNodes((int) (Math.random()*100), (nodes.get(randTemp)));
			}
			map.put(nodes.get(i), CN.get(i) );
			prevs.clear();
		}
	}
	
	public Map<Node, ConnectedNodes[]> getMap(){
		return map;
	}
	
	public ArrayList<Node> getNodes(){
		return nodes;
	}
	
	public ArrayList<Node> getShortestPath(Node startNode, Node endNode){
		while (k < (Math.pow(numberOfConnections, (mapSize - 1)))){
			currNode = startNode;
			path.add(currNode);
			
			for (int i = 0; i < mapSize-1; i++){
				pathCost+= map.get(currNode)[placeMarkers[i]].getPathCost();
				currNode = map.get(currNode)[placeMarkers[i]].getNode();
				
				
				
				if ((currNode.equals(endNode))||(path.contains(currNode))){
					if (((pathCost < shortestPathCost)||(shortestPathCost ==0))&&(!path.contains(currNode))){
						shortestPathCost = pathCost;
						shortestPath = new ArrayList<>();
						path.add(currNode);
						for (int j = 0; j < path.size(); j++){
							shortestPath.add(path.get(j));
						}
					}
					increment();
					i = mapSize;
				} else {
					path.add(currNode);
				}
			}
			k++;
			pathCost = 0;
			path = new ArrayList<>();
		}
		return shortestPath;
	}
	
	public void increment(){
		for (int i = placeMarkers.length-1; i >=0; i--){
			if (placeMarkers[i]>=numberOfConnections -1){
				placeMarkers[i] = 0;
			} else {
				placeMarkers[i]++;
				i = -1;
			}
		}
	}
	
	/*public ArrayList<Node> getThresholdPath(Node startNode, Node endNode, int thresh){
		
	}*/
	
	public String toString(){
		for (int i = 0; i < mapSize; i ++){
			printIt += nodes.get(i);
			printIt += " connects to ";
			for (int j = 0; j < numberOfConnections; j ++){
				printIt += map.get(nodes.get(i))[j];
			}
			printIt += "\n";
		}
		System.out.println(map.size());
		return printIt;
	}
}
